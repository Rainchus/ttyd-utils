### Guide to using the TTYD-Utils suite

The Python utilities in this directory cannot be used directly to create Paper
Mario: The Thousand-Year Door mods, but can be considered a means of creating
a directory in which one can look up the location of code one wishes to change.

To make full use of these utilities, you need:

* A reasonably up-to-date Python 3 installation with NumPy and Pandas available.
* A binary of PistonMiner's *ttydasm* tool
  (can be obtained [here](https://github.com/PistonMiner/ttyd-tools/releases)).
* The extracted boot.dol and \*.rel files from any version of TTYD.
* Either:
  * A .csv containing symbol data for the same version
    (**resources/us_symbols.csv**, or its PAL/JP equivalents can be used), or
  * .MAP files containing symbol information for the .dol and .rel files for
    the same version, which can be used to produce a symbol csv.
  
After acquiring them, you can run the utilities in this directory in the
following order (making sure to use the same *--out_path* for each invocation):

### Step 1. Dump the raw data from the sections of the .dol/.rel files.

**dump_sections.py** takes the .dol/.rel files provided, and outputs the following:
* A .csv file containing information regarding the type, size, and file-/RAM-relative
  locations of the sections of all the provided binary files.
* .raw dumps of every complete binary file and individual section.

Providing a link address (with optional area-specific overrides)
will also generate versions of the .REL file / section dumps that have
gone through the linking process, meaning e.g. pointers in evts or data
structures will have their values filled in rather than being placeholders.
Providing *some* value is required for many of the later utilities to run
correctly; by default, --link_address is set to an arbitrary value far enough
into the RAM space to not overlap the .DOL's sections, but it isn't the real
link address used for any particular version of TTYD.

Providing a rel_bss address will ensure that the .bss sections in .rel files
are correctly linked to a separate memory location; supplying an accurate
address (the address of the symbol *rel_bss seq_mapchange.o*) is not required,
but doing so will make sure the correct addresses are used for .rel BSS symbols
when exporting .MAP files in Step 3.

**Sample invocation:**
```
dump_sections.py \
  --out_path=YOUR_OUTPUT_PATH \
  --dol=PATH_TO_YOUR_DOL.dol \
  --rel=PATH_TO_YOUR_REL_FOR_AREA_*.rel \
  --link_address=0x80600000 \
  --link_address_overrides=jon:0x80c00000,tst:0x80c00000 \
  --rel_bss_address=0x80a00000
```

**As a side note**, if you're most interested in using these scripts as reference to
hex-edit the DOL or RELs, the symbol maps generated in Step 3 will tell you the
section-relative address of each symbol in the game, and you can add those
addresses to the file-level start addresses for their respective section listed
in the *section_info.csv* file generated by this step.

For instance, Lakitu's item drop table (*battle_item_jyugem battle_database_common.o*)
is located in the DOL's .data section with a section offset of **0x6b550**.
The *section_info.csv* file lists the DOL's .data section as starting at
file-level address **0x3011e0**. Adding these together gives you the address
0x3011e0 + 0x6b550 = **0x36c730**, which is the offset in the boot.dol file
that item drop table can be found at.

### Step 2. If necessary, convert your externally-sourced .MAP files to a symbol table.

* **NOTE:** *You can skip this step if using one of the already-provided **resources/\*_symbols.csv** files.*

Running the **map_to_symbols** and **annotate_map_symbols** utilities in sequence
will produce a .csv of symbols with the same columns as **resources/us_symbols.csv**,
and some heuristically-predicted common types (notably, strings and evts).
The resulting file will be in `YOUR_OUTPUT_PATH/annotated_symbols.csv`.

**Sample invocations:**
```
map_to_symbols.py \
  --out_path=YOUR_OUTPUT_PATH \
  --dol_map=PATH_TO_YOUR_DOL_MAP.map \
  --rel_map=PATH_TO_YOUR_REL_MAP_FOR_AREA_*.map

annotate_map_symbols.py --out_path=YOUR_OUTPUT_PATH
```

* You can also specify --encoding=YOUR_ALTERNATE_ENCODING if the .MAP files are
  in a *codecs*-supported encoding other than the default exported by
  **symbol_to_maps** (UTF-8).

### Step 3. Export .MAP files and ttydasm symbol files using the symbol table.

The **symbol_to_maps** utility produces .MAP files from your symbol table,
which can be useful if you don't already have them as a more human-readable
format (as well as for labeling symbols in the Dolphin emulator), as well as
symbol files for ttydasm, which are immensely useful for producing more 
readable script dumps.

The exact files produced are:
* One .MAP file and one ttydasm symbol file containing only the .dol symbols.
* Per .rel file:
  * One .MAP file and one ttydasm symbol file containing the .dol's symbols and 
    that .rel's symbols (w/RAM-relative addresses, as specified in Step 1).
  * One .MAP file containing only the .rel's symbols (w/section-relative addresses).

**Sample invocation:**
```
symbol_to_maps.py \
  --out_path=YOUR_OUTPUT_PATH \
  --symbols_path=PATH_TO_YOUR_SYMBOLS_FILE.csv \
  --rel_bss_address=0x80a00000
```

### Step 4. Export evt scripts to text files using ttydasm.

The **export_events** utility takes the ttydasm symbol files and dumped
sections, and uses PistonMiner's *ttydasm* tool to produce text dumps of
all symbols labeled with the "evt" type in the provided symbols csv.

The provided **resources/us_symbols.csv** file should have ~all such evts
in the US version of TTYD marked accurately; barring that, the binary in Step 2
should be fairly good at identifying them if you have the start addresses
correctly labeled.

**Example output script:**
```
...
805C6FE4:   switchi GSW(0)
805C6FEC:     case_int_lt 336
805C6FF4:       callc [evt_npc_set_position evt_npc.o] ["me"] 30 10 -950
805C700C:       callc [evt_npc_set_ry evt_npc.o] ["me"] 270
805C701C:   end_switch
...
```

**Sample invocation:**
```
export_events.py \
  --out_path=YOUR_OUTPUT_PATH \
  --symbols_path=PATH_TO_YOUR_SYMBOLS_FILE.csv \
  --ttydasm_exe=PATH_TO_TTYDASM.exe
```

### Step 5. Export instances of certain C data types to .csv files.

The **export_classes** utility takes the dumped section info from Step 1,
and produces .csv dumps containing the field values and bytewise representation
of all instances of the class types supported in **export_classes_parsers**.

Note that by default nothing will be exported if you're using the
**annotated_symbols.csv** file provided in Step 2; currently none of the
supported types are automatically detectable, and have to be manually annotated.
The **resources/us_symbols.csv** file should have most instances of the
supported types already annotated, however.

Currently, the list of supported types and their fields are hardcoded, but
support may be added to specify one's own struct definitions in the future.
These are the currently supported types (for the US version, if the struct
varies across versions; see **docs/ttyd_structures_pseudocode.txt** for
further reference):
```
AudienceItemWeight
BattleGroupSetup
BattleSetupData
BattleSetupNoTable
BattleSetupWeightedLoadout
BattleStageData
BattleStageFallObjectData
BattleStageNozzleData
BattleUnitPoseTable
BattleStageObjectData
BattleUnitDataTable
BattleUnitDefense
BattleUnitDefenseAttr
BattleUnitKind
BattleUnitKindPart
BattleUnitPoseTable
BattleUnitSetup
BattleWeapon
CookingRecipe
ItemData
ItemDropData
NpcAiTypeTable
PointDropData
ShopItemTable
ShopSellPriceList
StatusVulnerability
```

**Sample invocation:**
```
export_classes.py \
  --out_path=YOUR_OUTPUT_PATH \
  --symbols_path=PATH_TO_YOUR_SYMBOLS_FILE.csv
```

### Additional Tools

#### combine_event_dumps

The **combine_event_dumps** utility simply outputs all the event dumps from
**export_events** in a single text file, assuming it has already been run.

**Sample invocation:**
```
combine_event_dumps.py --out_path=YOUR_OUTPUT_PATH
```

#### combine_rels

The **combine_rels** utility can be used to construct a new relocatable file
composed of combinations of symbols from TTYD's original REL files.  This could
then be used in TTYD mods by adding it into a rebuilt ISO, or loaded from the
memory card using PistonMiner's REL framework.

The utility requires a dump of all the original .REL files that you wish to use,
as well as a text file with newline-delimited data ranges or symbol names to
include. (If using symbol names, you must also provide a symbol info .csv,
such as the **resources/us_symbols.csv** file in this repo for the US version).

If successful, the utility will output the combined REL, as well as a CSV file
that provides info on where the symbols / ranges are located in the new REL.

The utility will throw an error if a requested symbol matches multiple entries
in the provided symbol info file, or if a requested symbol / range has linking
dependencies that were not also included in the requested ranges. (Currently,
the utility does not have any functionality for looking up dependencies
proactively, but it should be able to detect if any are missing.)

Symbols of alignment greater than 4 for the .text section or 8 for the .rodata,
and .data, .bss sections are not supported, nor are sections other than
.text, .rodata, .data, and .bss with indices 1, 4, 5 and 6.

**Sample invocation for symbol names:**

```
combine_rels.py \
  --out_path=YOUR_OUTPUT_PATH \
  --rel=PATH_TO_YOUR_REL_FOR_AREA_*.rel \
  --symbol_info=PATH_TO_YOUR_SYMBOLS_FILE.csv \
  --symbol_names=SYMBOL_NAMES_PATH.txt
  
SYMBOL_NAMES_PATH.txt contents:

# All symbols related to Piranha Plant unit in MRI rel.
mri:unit_pakkun_flower.o:*
# All symbols related to Ember unit in MUJ rel.
muj:unit_hermos.o:*
# BattleGroupSetup information for an Ember fight in MUJ.
muj:battle_database_muj.o:btlparty_muj_muj_05_01

```

**Sample invocation for symbol ranges:**

```
combine_rels.py \
  --out_path=YOUR_OUTPUT_PATH \
  --rel=PATH_TO_YOUR_REL_FOR_AREA_*.rel \
  --symbol_ranges=SYMBOL_RANGES_PATH.txt
  
SYMBOL_RANGES_PATH.txt contents:

# All symbols related to Piranha Plant unit in MRI rel.
mri:1:0001ee0c-0001f09c
mri:4:00006ce8-00006ea8
mri:5:00032598-00033758
# All symbols related to Ember unit in MUJ rel.
muj:1:0000bcbc-0000c18c
muj:4:000064a0-00006684
muj:5:00039af0-0003b694
muj:6:00000070-000000c4
# BattleGroupSetup information for an Ember fight in MUJ.
muj:5:00020a78-00020b08

```